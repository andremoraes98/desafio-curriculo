## INNER JOIN

Como jÃ¡ comentado, o ``JOIN`` Ã© uma ferramenta do SQL para manipularmos dados que se encontram em diferentes tabelas. O mais comum e genÃ©rico Ã© o ``INNER JOIN``, que vamos tratar logo abaixo.

A sua sintaxe bÃ¡sica para acoplar duas tabelas Ã©:

> SELECT *tabela1.nome-coluna, tabela2.nome-coluna, . . .*  
> FROM tabela1  
> **INNER JOIN** tabela2  
> **ON** tabela1.coluna-chave-estrangeira = tabela2.coluna-referencia

Mas tambÃ©m Ã© possÃ­vel apelidar as tabelas, utilizando um **AS** (*alias*). Dessa forma, conseguimos utilizar o nome da tabela como o apelido dela, enxugando um pouco mais a *query*:

> SELECT *t1.nome-coluna, t2.nome-coluna, . . .*  
> FROM tabela1 **AS** *t1*  
> **INNER JOIN** tabela2 **AS** *t2*  
> **ON** t1.coluna-chave-estrangeira = t2.coluna-referencia  
>
>  > Vale ressaltar que Ã© possÃ­vel colocar quantas colunas fizerem sentido apÃ³s o SELECT. No entanto, o MySQL trarÃ¡ os dados da tabela explicitada antes do nome da coluna.  
>  >Por exemplo: caso haja uma coluna **name** na tabela1 e na tabela2, o MySQL trarÃ¡ os dados da tabela que foi explicitada antes do nome da coluna.

Agora, que tal trazer um exemplo para clarear o que foi falado? Vamos juntos?!

Esse exemplo foi baseado no banco de dados do [Sakila](https://assets.app.betrybe.com/back-end/sakila-1ae15ae82697888c35bf1f1c8acbf755.sql). 

O primeiro passo Ã© selecionarmos as colunas que queremos da primeira tabela, se atentando sempre para obedecer Ã  sintaxe: *tabela **.** nome-coluna*, como mostra a imagem abaixo:

![Primeiro passo](../images/FIRST_INNER_JOIN.png)

Quando conseguirmos trazer o resultado da *query*, sem erros, vamos ao segundo passo.

Agora vamos acoplar a tabela principal que contÃ©m a *foreign key* Ã  tabela secundÃ¡ria, que contÃ©m os dados que queremos acoplar. Para isso, vamos apenas acrescentar o ``INNER JOIN`` e o ``ON``, como mostra a imagem abaixo:

![Segundo passo](../images/SECOND_INNER_JOIN.png)

Ã‰ esperado que o MySQL nos traga o mesmo resultado, sem acusar erro.  

Repare que logo apÃ³s o ``ON``, Ã© informado qual Ã© a coluna que representa a *foreign key* na tabela principal e qual Ã© a coluna que ela aponta na tabela secundÃ¡ria.

Com esta etapa concluÃ­da com sucesso, sem erros, as nossas tabelas estÃ£o acopladas com **SUCESSO!**

> **UHULLL!!!**

De agora em diante, basta apenas alterar o nome da tabela com o nome da sua respectiva coluna. No exemplo, tiramos o id da linguagem que o filme foi feito para deixar apenas o nome da linguagem, dando um apelido de *language* para esta coluna.

> *NÃ£o fica muito mais legÃ­vel?*

![Terceiro passo](../images/THIRD_INNER_JOIN.png)

No nosso Ãºltimo exemplo, adicionamos mais uma coluna ao resultado final, para que vocÃª possa entender o quÃ£o simples e mÃ¡gico Ã© manipular dados relacionais com o ``INNER JOIN``! 

Fala sÃ©rio! Isso nÃ£o Ã© incrÃ­vel?

![Quarto passo](../images/FOURTH_INNER_JOIN.png)

---

### ExercÃ­cios de fixaÃ§Ã£o

1. Construa uma *query* que retorne o primeiro nome do cliente (na tabela *customer*) e o nÃºmero de telefone dele (na tabela *address*).

2. Construa uma *query* que retorne a data do aluguel (na tabela *rental*) e o primeiro nome do cliente que fez o aluguel (na tabela *customer*).

---

#### Explorado o ``INNER JOIN``, vamos agora falar um pouco do ``LEFT JOIN`` e ``RIGHT JOIN``. Pra cima!!! ðŸš€ðŸš€ðŸš€