## LEFT JOIN e RIGHT JOIN 

Compreendido o conceito de ``INNER JOIN``, vamos tratar agora outros dois tipos de ``JOINs``: o ``LEFT`` e o ``RIGHT``.

A sintaxe √© padr√£o. Ent√£o, como voc√™ deve estar imaginando, a √∫nica coisa que muda √©, de fato, o tipo de ``JOIN`` que estamos chamando. Tomando o nosso √∫ltimo caso como exemplo:

> SELECT *t1.nome-coluna, t2.nome-coluna, . . .*  
> FROM tabela1 AS *t1*  
> **INNER JOIN** tabela2 AS *t2*  
> **ON** t1.coluna-chave-estrangeira = t2.coluna-referencia

Caso quis√©ssemos alterar o tipo de ``JOIN``, basta somente alterar o ``INNER`` por ``LEFT`` ou ``RIGHT``, ficando assim:

> SELECT *t1.nome-coluna, t2.nome-coluna, . . .*  
> FROM tabela1 AS *t1*  
> **LEFT** JOIN tabela2 AS *t2*  
> ON t1.coluna-chave-estrangeira = t2.coluna-referencia
>
> > Ou
>
> SELECT *t1.nome-coluna, t2.nome-coluna, . . .*  
> FROM tabela1 AS *t1*  
> **RIGHT** JOIN tabela2 AS *t2*  
> ON t1.coluna-chave-estrangeira = t2.coluna-referencia

Dito isso, √© dessa forma que alteramos a sintaxe n√£o s√≥ para o ``LEFT`` ou ``RIGHT JOIN`` como tamb√©m para qualquer outro tipo de ``JOIN``!

> *T√°, mas por que eu utilizaria outro tipo de ``JOIN`` se o ``INNER`` j√° satisfaz as minhas necessidades?*  
> Ser√° mesmo . . . ?

Digamos que voc√™ tenha duas tabelas: uma com Personagens e outra que armazena o tipo dos personagens (principal, secund√°rio, etc). Se voc√™ quiser retornar **TODOS** os tipos armazenados e trazer tamb√©m os personagens que est√£o relacionados com esse tipo, como faria?  

![Tabela personagem](../images/conteudo/PERSONAGEM_TABLE.png)
![Tabela tipo](../images/conteudo/TIPO_TABLE.png)

Provavelmente, com o que falamos at√© aqui, desta forma:  

![Resultado do Inner Join entre tipo e personagem](../images/conteudo/PERSON_TIPO_INNER_JOIN_RESULT.png)  

No entanto, h√° um dado que n√£o foi trazido pelo ``JOIN``, na tabela tipo, que √© o valor *'Secund√°rio'*... ***E agora?!*** ü§î  

Para solucionar esse tipo de desafio, utilizamos o recurso do ``LEFT`` ou ``RIGHT JOIN``, a depender de qual tabela √© tida como refer√™ncia. Observemos o mesmo exemplo, mas agora trocando o ``INNER`` pelo ``LEFT``:  

![Resultado do Inner Join entre tipo e personagem](../images/conteudo/PERSON_TIPO_LEFT_JOIN_RESULT.png)  

Desta forma, mesmo n√£o havendo nenhum personagem com aquele tipo, a *query* retorna **TODOS** os valores da tabela tipo. E os que n√£o possuem correspond√™ncia, s√£o preenchidos com *null* (nulo).

Portanto, de agora em diante, caso queira trazer todos os dados de uma tabela espec√≠fica, acoplada a outra tabela, basta usar o ``LEFT`` ou ``RIGHT JOIN``!   

>Se a tabela principal for a nossa refer√™ncia, utilizamos o ``LEFT JOIN``. Se for a tabela secund√°ria (que vem ap√≥s instanciarmos o ``JOIN``), utilizamos o ``RIGHT JOIN``.

---

### Exerc√≠cios de fixa√ß√£o

1. Construa uma *query* que retorne o valor do aluguel (na tabela *payment*) e o *id* do aluguel (na tabela *rental*), acoplando as tabelas atrav√©s do ``LEFT JOIN``.

2. Refa√ßa o exerc√≠cio anterior trocando o ``LEFT JOIN`` por ``RIGHT JOIN``.

> No exerc√≠cio 1, h√° alguns valores cujo o *id* do aluguel √© nulo. No entanto, quando acoplamos com o ``RIGHT JOIN`` (exerc√≠cio 2), n√£o h√° nenhum *id* do aluguel nulo.  
> *Agora, por que no exerc√≠cio 1 h√° retornos nulos e no exerc√≠cio 2 n√£o h√°?!* ü§î   

---

#### Agora, voc√™ possui o ``INNER``, ``LEFT`` e o ``RIGHT`` no leque de ``JOINS``. O que acha de adicionarmos tamb√©m o ``SELF``?! 